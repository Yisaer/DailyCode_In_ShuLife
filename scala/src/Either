package com.yisa

/**
  * Created by gaoson on 8/14/2017.
  */




sealed trait Either[+E,+A] {
  def map[B](f: A => B): Either[E, B] =
    this match {
      case Right(a) => Right(f(a))
      case Left(e) => Left(e)
    }


  def flatMap[EE >: E, B](f: A => Either[EE, B]): Either[EE, B] =
    this match {
      case Left(e) => Left(e)
      case Right(a) => f(a)
    }


  def orElse[EE >: E, B >: A](b: => Either[EE, B]): Either[EE, B] =
    this match {
      case Left(_) => b
      case Right(a) => Right(a)
    }

  def map2[EE >: E, B, C](b: Either[EE, B])(f: (A, B) => C): Either[EE, C] =
    for( a<- this ;b1 <- b ) yield f(a,b1)

}
case class Left[+E](get: E) extends Either[E,Nothing]
case class Right[+A](get: A) extends Either[Nothing,A]


object Either{
  def mean(xs : IndexedSeq[Double]): Either[String,Double] =
    if (xs.isEmpty)
      Left("mean of empty list")
    else
      Right(xs.sum / xs.length)

  def Try[A] (a: => A) : Either[Exception,A] =
    try Right(a)
    catch {
      case e : Exception => Left(e)
    }

  def safeDive(x:Int , y: Int) :Either[Exception,Int] =
    try Right(x/y)
    catch{
      case e: Exception => Left(e)
    }

  def sequence[E,A](es:List[Either[E,A]]):Either[E,List[A]] =
    es match {
      case Nil => Right(Nil)
      case h::t => h flatMap( hh => sequence(t) map( hh ::_) )
    }

  def OutMap2[E,A,B,C](a:Right[A] ,b:Right[B])(f: (A,B) => C ):Either[E,C] =
    a flatMap( aa => b map(bb => f(aa,bb)))

  def traverse[E,A,B](as:List[A])(f: A=>Either[E,B]) : Either[E,List[B]] =
    as match {
      case Nil => Right(Nil)
      case h::t =>(f(h) map2 traverse(t)(f))(_ :: _)
    }

  def seqViaTraverse[E,A](es: List[Either[E,A]]):Either[E,List[A]] =
    traverse(es)( x => x)


}
